vector : 동적 배열

template<typename T>
void sum3(T&&a){
   a++;
}


lvalue면 lvalue로 처리, rvalue면 rvalue로 처리.
위와 같이 template &&을 쓸 경우. (※ 매개변수 &&는 template만 가능)

set/map insert 같은 함수의 반환 값이 보통 iterator가 반환. 값이 없으면 end가 반환

reverse iterator는 그냥 iterator와 다름. 따라서 erase의 매개변수로 들어갈 수 없음. 
--s.end()  써야함.

맨 앞/뒤에만 조작을 가한다면 굳이 iterator가 필요 없음.

pair는 기본적으로 operator가 구현되어 잇음

Set에서 erase에서 it로 지우면 O(1), Key로 지우면 O(log(N))

---------------- 3일차 : hash -------------------

&인 매개변수에 값을 전달할 경우, Rvalue(임시성)는 안됨. Lvalue여야 함. 
차라리 이런 것 때문에 &&으로 매개변수를 선언하는 것이 좋음.

& : LValue만 받겠어
&& : LValue, RValue 상관 안하겠어.

unordered_set/map은 내부적으로 list, chaining 사용

unordered_set/map에서 iterator는 입력된 순서대로 아님.(사용X)
bucket()은 당근 흩뿌려서 저장

insert 한 번 없이, htab3[0]처럼 접근하면. 알아서 해당 bucket에 값 추가. 그러므로 htab.size()가 0->1로 변경

map을 사용할 때, {key, value}의 value로 무게가 있는 struct 넣는거 지양하고, 해당 struct의 id? 정도를 넣고, 
별도 struct 배열에서 따로 멤버변수들 구성해주기. (성능)

기존재하는 key를 hTab.insert 하면 삽입 안함.

없는 key를 erase()해도 별 문제 X

상태를 저장 및 검색 = HASH

function call operator()란...

hash custorm 반환형은 size_t이지만 unsigned long long도 된다. 양수면 되는 듯.

<int, int, hash<int>, MyEqual>